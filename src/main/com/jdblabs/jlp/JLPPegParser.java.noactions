package com.jdblabs.jlp;

import com.jdblabs.jlp.ast.*;
import java.util.ArrayList;
import java.util.List;
import org.parboiled.Action;
import org.parboiled.BaseParser;
import org.parboiled.Context;
import org.parboiled.Rule;
import org.parboiled.annotations.*;

import static com.jdblabs.jlp.ast.TextBlock.makeCodeBlock;
import static com.jdblabs.jlp.ast.TextBlock.makeMarkdownBlock;

@BuildParseTree
public class JLPPegParser extends BaseParser<Object> {

    public Rule CodePage() {
        return ZeroOrMore(FirstOf(
                DocBlock(),
                CodeBlock())); }

    /**
     * Parses the rule:
     *  DocBlock = DirectiveBlock / MarkdownBlock
     *
     * Pushes a DocBlock object onto the stack.
     */
    Rule DocBlock() {
        return OneOrMore(FirstOf(
                    DirectiveBlock(),
                    MarkdownBlock())); }

    /**
     * Parses the rule:
     *  CodeBlock = !DOC_START RemainingLine
     *
     * Pushes a CodeBlock onto the stack.
     */
    Rule CodeBlock() {
        return Sequence(
            TestNot(DOC_START), RemainingLine(),
            ZeroOrMore(Sequence(
                TestNot(DOC_START), RemainingLine()))); }

    /**
     * Parses the rule:
     *  DirectiveBlock =
     *      DOC_START DIRECTIVE_START (LongDirective / LineDirective)
     *
     * Pushes a Directive onto the stack.
     */
    Rule DirectiveBlock() {
        return Sequence(
            DOC_START, DIRECTIVE_START,
            FirstOf(LongDirective(), LineDirective())); }

    /**
     * Parses the rule:
     *  LongDirective =
     *      (AUTHOR_DIR / DOC_DIR / EXAMPLE_DIR) RemainingLine MarkdownBlock?
     * 
     * Pushes a Directive object onto the value stack.
     */
    Rule LongDirective() {
        return Sequence(
            FirstOf(AUTHOR_DIR, DOC_DIR, EXAMPLE_DIR),
            RemainingLine(),
            Optional(MarkdownBlock())); }

    /**
     * Parses the rule:
     *  LineDirective = 
     *      ORG_DIR RemainingLine
     *
     * Pushes a Directive object onto the value stack.
     */
    Rule LineDirective() {
        return Sequence(
            ORG_DIR,
            RemainingLine()); }

    /**
     * Parses the rule:
     *  MarkdownBlock =  MarkdownLine+
     *
     * Pushes a MarkdownBlock onto the stack as a string.
     */
    Rule MarkdownBlock() { return OneOrMore(MarkdownLine()); }

    /**
     * Parses the rule:
     *  MarkdownLine =
     *      DOC_START !DIRECTIVE_START RemainingLine
     *
     * Pushes the line value (not including the DOC_START) onto the stack.
     */
    Rule MarkdownLine() {
        return Sequence(
            DOC_START, TestNot(DIRECTIVE_START), RemainingLine()); }

    /**
     * Parses the rule:
     *  RemainingLine = (!EOL)+ EOL
     */
    @SuppressSubnodes
    Rule RemainingLine() {
        return Sequence(OneOrMore(NOT_EOL), EOL); }

    Rule DOC_START      = String("%% ");
    Rule EOL            = FirstOf(Ch('\n'), EOI);
    Rule NOT_EOL        = Sequence(TestNot(EOL), ANY);
    Rule DIRECTIVE_START= Ch('@');
    Rule SLASH          = Ch('/');

    // directive terminals
    Rule AUTHOR_DIR   = IgnoreCase("author");
    Rule DOC_DIR      = IgnoreCase("doc");
    Rule EXAMPLE_DIR  = IgnoreCase("example");
    Rule ORG_DIR      = IgnoreCase("org");

    String popAsString() {
        return (String) pop(); }

    List<ASTNode> addToList(ASTNode value, List<ASTNode> list) {
        list.add(value);
        return list; }

    boolean printValueStack() {
        for (int i = 0; i < getContext().getValueStack().size(); i++) {
            System.out.println(i + ": " + peek(i)); }
        return true; }
}
